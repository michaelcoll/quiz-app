/*
 * Copyright (c) 2025 MichaÃ«l COLL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: student_class.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const assignUserToClass = `-- name: AssignUserToClass :exec
UPDATE user
SET class_uuid = ?
WHERE id = ?
`

type AssignUserToClassParams struct {
	ClassUuid uuid.UUID `db:"class_uuid"`
	ID        string    `db:"id"`
}

func (q *Queries) AssignUserToClass(ctx context.Context, arg AssignUserToClassParams) error {
	_, err := q.db.ExecContext(ctx, assignUserToClass, arg.ClassUuid, arg.ID)
	return err
}

const countAllClasses = `-- name: CountAllClasses :one
SELECT COUNT(1)
FROM student_class
`

func (q *Queries) CountAllClasses(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllClasses)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countClassById = `-- name: CountClassById :one
SELECT COUNT(1)
FROM student_class
WHERE uuid = ?
`

func (q *Queries) CountClassById(ctx context.Context, argUuid uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClassById, argUuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrReplaceClass = `-- name: CreateOrReplaceClass :exec
REPLACE INTO student_class (uuid, name)
VALUES (?, ?)
`

type CreateOrReplaceClassParams struct {
	Uuid uuid.UUID `db:"uuid"`
	Name string    `db:"name"`
}

func (q *Queries) CreateOrReplaceClass(ctx context.Context, arg CreateOrReplaceClassParams) error {
	_, err := q.db.ExecContext(ctx, createOrReplaceClass, arg.Uuid, arg.Name)
	return err
}

const createQuizClassVisibility = `-- name: CreateQuizClassVisibility :exec
REPLACE INTO quiz_class_visibility (class_uuid, quiz_sha1)
VALUES (?, ?)
`

type CreateQuizClassVisibilityParams struct {
	ClassUuid uuid.UUID `db:"class_uuid"`
	QuizSha1  string    `db:"quiz_sha1"`
}

func (q *Queries) CreateQuizClassVisibility(ctx context.Context, arg CreateQuizClassVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, createQuizClassVisibility, arg.ClassUuid, arg.QuizSha1)
	return err
}

const deleteClassById = `-- name: DeleteClassById :exec
DELETE
FROM student_class
WHERE uuid = ?
`

func (q *Queries) DeleteClassById(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteClassById, argUuid)
	return err
}

const deleteQuizClassVisibility = `-- name: DeleteQuizClassVisibility :exec
DELETE
FROM quiz_class_visibility
WHERE class_uuid = ?
  AND quiz_sha1 = ?
`

type DeleteQuizClassVisibilityParams struct {
	ClassUuid uuid.UUID `db:"class_uuid"`
	QuizSha1  string    `db:"quiz_sha1"`
}

func (q *Queries) DeleteQuizClassVisibility(ctx context.Context, arg DeleteQuizClassVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, deleteQuizClassVisibility, arg.ClassUuid, arg.QuizSha1)
	return err
}

const findAllClasses = `-- name: FindAllClasses :many
SELECT uuid, name
FROM student_class
LIMIT ? OFFSET ?
`

type FindAllClassesParams struct {
	Limit  int64 `db:"limit"`
	Offset int64 `db:"offset"`
}

func (q *Queries) FindAllClasses(ctx context.Context, arg FindAllClassesParams) ([]StudentClass, error) {
	rows, err := q.db.QueryContext(ctx, findAllClasses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StudentClass{}
	for rows.Next() {
		var i StudentClass
		if err := rows.Scan(&i.Uuid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
