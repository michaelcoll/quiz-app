/*
 * Copyright (c) 2023-2025 MichaÃ«l COLL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: session.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const countAllSessions = `-- name: CountAllSessions :one
SELECT COUNT(*)
FROM session_view
WHERE quiz_active = ?
`

func (q *Queries) CountAllSessions(ctx context.Context, quizActive bool) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllSessions, quizActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllSessionsForUser = `-- name: CountAllSessionsForUser :one
SELECT COUNT(*)
FROM session_view
WHERE quiz_active = ?
  AND user_id = ?
`

type CountAllSessionsForUserParams struct {
	QuizActive bool   `db:"quiz_active"`
	UserID     string `db:"user_id"`
}

func (q *Queries) CountAllSessionsForUser(ctx context.Context, arg CountAllSessionsForUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllSessionsForUser, arg.QuizActive, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrReplaceSession = `-- name: CreateOrReplaceSession :exec
INSERT INTO session (uuid, quiz_sha1, user_id)
VALUES (?, ?, ?)
`

type CreateOrReplaceSessionParams struct {
	Uuid     uuid.UUID `db:"uuid"`
	QuizSha1 string    `db:"quiz_sha1"`
	UserID   string    `db:"user_id"`
}

func (q *Queries) CreateOrReplaceSession(ctx context.Context, arg CreateOrReplaceSessionParams) error {
	_, err := q.db.ExecContext(ctx, createOrReplaceSession, arg.Uuid, arg.QuizSha1, arg.UserID)
	return err
}

const createOrReplaceSessionAnswer = `-- name: CreateOrReplaceSessionAnswer :exec
REPLACE INTO session_answer (session_uuid, question_sha1, answer_sha1, checked)
VALUES (?, ?, ?, ?)
`

type CreateOrReplaceSessionAnswerParams struct {
	SessionUuid  uuid.UUID `db:"session_uuid"`
	QuestionSha1 string    `db:"question_sha1"`
	AnswerSha1   string    `db:"answer_sha1"`
	Checked      bool      `db:"checked"`
}

func (q *Queries) CreateOrReplaceSessionAnswer(ctx context.Context, arg CreateOrReplaceSessionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, createOrReplaceSessionAnswer,
		arg.SessionUuid,
		arg.QuestionSha1,
		arg.AnswerSha1,
		arg.Checked,
	)
	return err
}

const findAllSessions = `-- name: FindAllSessions :many
SELECT uuid, quiz_sha1, quiz_name, quiz_active, user_id, user_name, user_picture, remaining_sec, checked_answers, results
FROM session_view
WHERE quiz_active = ?
LIMIT ? OFFSET ?
`

type FindAllSessionsParams struct {
	QuizActive bool  `db:"quiz_active"`
	Limit      int64 `db:"limit"`
	Offset     int64 `db:"offset"`
}

func (q *Queries) FindAllSessions(ctx context.Context, arg FindAllSessionsParams) ([]SessionView, error) {
	rows, err := q.db.QueryContext(ctx, findAllSessions, arg.QuizActive, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionView{}
	for rows.Next() {
		var i SessionView
		if err := rows.Scan(
			&i.Uuid,
			&i.QuizSha1,
			&i.QuizName,
			&i.QuizActive,
			&i.UserID,
			&i.UserName,
			&i.UserPicture,
			&i.RemainingSec,
			&i.CheckedAnswers,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllSessionsAnswerForSession = `-- name: FindAllSessionsAnswerForSession :many
SELECT srv.quiz_sha1,
       srv.question_sha1,
       srv.answer_sha1,
       srv.session_uuid,
       srv.user_id,
       srv.checked,
       CASE
           WHEN sv.remaining_sec = 0
               THEN srv.result
           END
FROM session_response_view srv
         JOIN session_view sv ON srv.session_uuid = sv.uuid
WHERE session_uuid = ?
  AND srv.user_id = ?
`

type FindAllSessionsAnswerForSessionParams struct {
	SessionUuid uuid.UUID `db:"session_uuid"`
	UserID      string    `db:"user_id"`
}

type FindAllSessionsAnswerForSessionRow struct {
	QuizSha1     string      `db:"quiz_sha1"`
	QuestionSha1 string      `db:"question_sha1"`
	AnswerSha1   string      `db:"answer_sha1"`
	SessionUuid  uuid.UUID   `db:"session_uuid"`
	UserID       string      `db:"user_id"`
	Checked      bool        `db:"checked"`
	Column7      interface{} `db:"column_7"`
}

func (q *Queries) FindAllSessionsAnswerForSession(ctx context.Context, arg FindAllSessionsAnswerForSessionParams) ([]FindAllSessionsAnswerForSessionRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllSessionsAnswerForSession, arg.SessionUuid, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllSessionsAnswerForSessionRow{}
	for rows.Next() {
		var i FindAllSessionsAnswerForSessionRow
		if err := rows.Scan(
			&i.QuizSha1,
			&i.QuestionSha1,
			&i.AnswerSha1,
			&i.SessionUuid,
			&i.UserID,
			&i.Checked,
			&i.Column7,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllSessionsForUser = `-- name: FindAllSessionsForUser :many
SELECT uuid, quiz_sha1, quiz_name, quiz_active, user_id, user_name, user_picture, remaining_sec, checked_answers, results
FROM session_view
WHERE quiz_active = ?
  AND user_id = ?
LIMIT ? OFFSET ?
`

type FindAllSessionsForUserParams struct {
	QuizActive bool   `db:"quiz_active"`
	UserID     string `db:"user_id"`
	Limit      int64  `db:"limit"`
	Offset     int64  `db:"offset"`
}

func (q *Queries) FindAllSessionsForUser(ctx context.Context, arg FindAllSessionsForUserParams) ([]SessionView, error) {
	rows, err := q.db.QueryContext(ctx, findAllSessionsForUser,
		arg.QuizActive,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionView{}
	for rows.Next() {
		var i SessionView
		if err := rows.Scan(
			&i.Uuid,
			&i.QuizSha1,
			&i.QuizName,
			&i.QuizActive,
			&i.UserID,
			&i.UserName,
			&i.UserPicture,
			&i.RemainingSec,
			&i.CheckedAnswers,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
