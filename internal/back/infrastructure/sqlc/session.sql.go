// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: session.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createOrReplaceSession = `-- name: CreateOrReplaceSession :exec
REPLACE INTO session (uuid, quiz_sha1, user_id, created_at)
VALUES (?, ?, ?, ?)
`

type CreateOrReplaceSessionParams struct {
	Uuid      uuid.UUID `db:"uuid"`
	QuizSha1  string    `db:"quiz_sha1"`
	UserID    string    `db:"user_id"`
	CreatedAt time.Time `db:"created_at"`
}

func (q *Queries) CreateOrReplaceSession(ctx context.Context, arg CreateOrReplaceSessionParams) error {
	_, err := q.db.ExecContext(ctx, createOrReplaceSession,
		arg.Uuid,
		arg.QuizSha1,
		arg.UserID,
		arg.CreatedAt,
	)
	return err
}

const createOrReplaceSessionAnswer = `-- name: CreateOrReplaceSessionAnswer :exec
REPLACE INTO session_answer (session_uuid, question_sha1, answer_sha1, checked)
VALUES (?, ?, ?, ?)
`

type CreateOrReplaceSessionAnswerParams struct {
	SessionUuid  string `db:"session_uuid"`
	QuestionSha1 string `db:"question_sha1"`
	AnswerSha1   string `db:"answer_sha1"`
	Checked      int64  `db:"checked"`
}

func (q *Queries) CreateOrReplaceSessionAnswer(ctx context.Context, arg CreateOrReplaceSessionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, createOrReplaceSessionAnswer,
		arg.SessionUuid,
		arg.QuestionSha1,
		arg.AnswerSha1,
		arg.Checked,
	)
	return err
}

const findAllSessions = `-- name: FindAllSessions :many
SELECT uuid, quiz_sha1, quiz_name, quiz_active, user_id, user_name, remaining_sec
FROM session_view
WHERE quiz_active = ?
`

func (q *Queries) FindAllSessions(ctx context.Context, quizActive int64) ([]SessionView, error) {
	rows, err := q.db.QueryContext(ctx, findAllSessions, quizActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionView{}
	for rows.Next() {
		var i SessionView
		if err := rows.Scan(
			&i.Uuid,
			&i.QuizSha1,
			&i.QuizName,
			&i.QuizActive,
			&i.UserID,
			&i.UserName,
			&i.RemainingSec,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllSessionsAnswerForSession = `-- name: FindAllSessionsAnswerForSession :many
SELECT srv.quiz_sha1,
       srv.question_sha1,
       srv.answer_sha1,
       srv.session_uuid,
       srv.user_id,
       srv.checked,
       CASE
           WHEN sv.remaining_sec = 0
               THEN srv.result
           END
FROM session_response_view srv
         JOIN session_view sv ON srv.session_uuid = sv.uuid
WHERE session_uuid = ?
  AND srv.user_id = ?
`

type FindAllSessionsAnswerForSessionParams struct {
	SessionUuid uuid.UUID `db:"session_uuid"`
	UserID      string    `db:"user_id"`
}

type FindAllSessionsAnswerForSessionRow struct {
	QuizSha1     string      `db:"quiz_sha1"`
	QuestionSha1 string      `db:"question_sha1"`
	AnswerSha1   string      `db:"answer_sha1"`
	SessionUuid  uuid.UUID   `db:"session_uuid"`
	UserID       string      `db:"user_id"`
	Checked      int64       `db:"checked"`
	Column7      interface{} `db:"column_7"`
}

func (q *Queries) FindAllSessionsAnswerForSession(ctx context.Context, arg FindAllSessionsAnswerForSessionParams) ([]FindAllSessionsAnswerForSessionRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllSessionsAnswerForSession, arg.SessionUuid, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllSessionsAnswerForSessionRow{}
	for rows.Next() {
		var i FindAllSessionsAnswerForSessionRow
		if err := rows.Scan(
			&i.QuizSha1,
			&i.QuestionSha1,
			&i.AnswerSha1,
			&i.SessionUuid,
			&i.UserID,
			&i.Checked,
			&i.Column7,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllSessionsForUser = `-- name: FindAllSessionsForUser :many
SELECT uuid, quiz_sha1, quiz_name, quiz_active, user_id, user_name, remaining_sec
FROM session_view
WHERE quiz_active = ?
  AND user_id = ?
`

type FindAllSessionsForUserParams struct {
	QuizActive int64  `db:"quiz_active"`
	UserID     string `db:"user_id"`
}

func (q *Queries) FindAllSessionsForUser(ctx context.Context, arg FindAllSessionsForUserParams) ([]SessionView, error) {
	rows, err := q.db.QueryContext(ctx, findAllSessionsForUser, arg.QuizActive, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionView{}
	for rows.Next() {
		var i SessionView
		if err := rows.Scan(
			&i.Uuid,
			&i.QuizSha1,
			&i.QuizName,
			&i.QuizActive,
			&i.UserID,
			&i.UserName,
			&i.RemainingSec,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
